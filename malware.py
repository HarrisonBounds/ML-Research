import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import SelectFromModel
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, f1_score, recall_score, precision_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
import seaborn as sns
import time
from sdv.single_table import CTGANSynthesizer
from sdv.single_table import GaussianCopulaSynthesizer
from sdv.metadata import SingleTableMetadata
from CTABGAN import gan
from ctgan import CTGAN
from table_evaluator import TableEvaluator


def encode_labels(y_train, y_test):
    #Covert the text labels to numbers so the model can understand it
    label_encoder = LabelEncoder()

    y_train_encoded = label_encoder.fit_transform(y_train)
    y_test_encoded = label_encoder.fit_transform(y_test)

    class_names = label_encoder.classes_

    print("Class names: ", class_names)

    return y_train_encoded, y_test_encoded, class_names



def binary_classification(X_train, y_train, X_test, y_test, num_trees):
    positive_class = "BenignTraffic"

    #Create binary labels where benign is 1 and malicious is 0
    y_train_binary = (y_train == positive_class).astype(int)
    y_test_binary = (y_test == positive_class).astype(int)

    #Training binary classifier
    binary_classifier = RandomForestClassifier(n_estimators=num_trees, criterion='entropy', class_weight='balanced', random_state=50)
    binary_classifier.fit(X_train, y_train_binary)

    # Predict using the binary classifier
    y_pred_binary = binary_classifier.predict(X_test)
    y_pred_prob_binary = binary_classifier.predict_proba(X_test)[:, 1]  # Use the probability for the positive class

    return y_test_binary, y_pred_binary, y_pred_prob_binary


def multi_class_classification(X_train, y_train_encoded, X_test, num_trees, feature_selection):
    print("Training...")
    start_time = time.time()
    
    if feature_selection:
        sel = SelectFromModel(RandomForestClassifier(n_estimators=num_trees, criterion='gini', min_samples_leaf=2, max_depth=None, verbose=True))
        sel.fit(X_train, y_train_encoded)

        X_train = sel.transform(X_train)
        X_test = sel.transform(X_test)
        
    else:
        X_train = X_train
        X_test = X_test

    classifier = RandomForestClassifier(n_estimators=num_trees, criterion='gini', min_samples_leaf=2, max_depth=None, verbose=True)
    classifier.fit(X_train, y_train_encoded)
    
    end_time = time.time()

    print(f'It took {(end_time-start_time)/60} minutes to train')

    print("Predicting...")
    start_time = time.time()
    y_pred = classifier.predict(X_test)
    end_time = time.time()

    print(f'It took {(end_time-start_time)/60} minutes to predict')
    
    return y_pred
    
def show_confusion_matrix(y_test, y_pred, malware_type, class_names, num_trees):
    confusion_mat = confusion_matrix(y_test, y_pred)

    plt.figure(figsize=(14, 10))
    sns.heatmap(confusion_mat, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.title(f'Confusion Matrix for {malware_type} using Random Forest Classification with {num_trees} Trees')
    plt.show()

def main():
    
    mal_path = 'E:\\Malware Data Set\\Obfuscated-MalMem2022.csv'
    num_trees = 500
    gan_model = None
    gen_type = None
    benign = True
    feature_selection = True
    label_column = "Category"
    class_column = 'Class'
    
    df = pd.read_csv(mal_path)

    #Clip the random string of letters and numbers in the label column
    df['Category'] = df['Category'].str.split('-').str.slice(stop=2).str.join('-')

    # df_gen_type = df_original[df_original[label_column].str.contains(gen_type)]

    #Only classify malicious data
    if benign:
        df = df[df[label_column] != 'Benign']

    #Drop the 'Malware' column
    df = df.drop(class_column, axis=1)

    if gan_model: 
        #Convert dataframe into metadata
        metadata = SingleTableMetadata()
        metadata.detect_from_dataframe(df)

        #Generate synthetic data
        print("Generating Synthetic Data...")
        start_time = time.time()
        synthesizer = GaussianCopulaSynthesizer(metadata)
        synthesizer.fit(df)
        end_time = time.time()

        print(f'It took {(end_time-start_time)/60} minutes to generate')

        num_generated_rows = len(df)

        synthetic_data = synthesizer.sample(num_rows=100)

        # save the data as a CSV
        synthetic_data.to_csv('synthetic_data.csv', index=False)

        df = pd.concat([df, synthetic_data], ignore_index=True)

        df.to_csv('concat_data.csv', index=False)
    
    X = df.drop([label_column], axis=1)
    y = df[label_column]

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, shuffle=True)

    #Get the encoded labels
    y_train_encoded, y_test_encoded, class_names = encode_labels(y_train, y_test)

    #Model you want to run
    y_pred = multi_class_classification(X_train, y_train_encoded, X_test, num_trees, feature_selection)

    #Evaluate the model
    print(classification_report(y_test_encoded, y_pred, target_names=class_names))

    #Display confusion matrix
    #show_confusion_matrix(y_test_encoded, y_pred, gen_type, class_names, num_trees)

       
if __name__ == "__main__":
    main()