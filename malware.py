import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import GridSearchCV
from sklearn.feature_selection import SelectFromModel
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
import seaborn as sns
import time
from sdv.single_table import CTGANSynthesizer
from sdv.single_table import GaussianCopulaSynthesizer
from sdv.metadata import SingleTableMetadata
from sdv.evaluation.single_table import run_diagnostic
from sdv.evaluation.single_table import evaluate_quality
from table_evaluator import TableEvaluator
import json
import sys
sys.path.append('E:\ML-Research\CTAB')
from CTAB.model import ctabgan


def encode_labels(y_train, y_test):
    #Covert the text labels to numbers so the model can understand it
    label_encoder = LabelEncoder()

    y_train_encoded = label_encoder.fit_transform(y_train)
    y_test_encoded = label_encoder.fit_transform(y_test)

    class_names = label_encoder.classes_

    print("Class names: ", class_names)

    return y_train_encoded, y_test_encoded, class_names



def binary_classification(X_train, y_train, X_test, y_test, num_trees):
    positive_class = "BenignTraffic"

    #Create binary labels where benign is 1 and malicious is 0
    y_train_binary = (y_train == positive_class).astype(int)
    y_test_binary = (y_test == positive_class).astype(int)

    #Training binary classifier
    binary_classifier = RandomForestClassifier(n_estimators=num_trees, criterion='entropy', class_weight='balanced', random_state=50)
    binary_classifier.fit(X_train, y_train_binary)

    # Predict using the binary classifier
    y_pred_binary = binary_classifier.predict(X_test)
    y_pred_prob_binary = binary_classifier.predict_proba(X_test)[:, 1]  # Use the probability for the positive class

    return y_test_binary, y_pred_binary, y_pred_prob_binary


def multi_class_classification(X_train, y_train_encoded, X_test, num_trees, classification):
    print("Training...")
    start_time = time.time()
    
    #Classification selection
    if classification == "RF":
        classifier = RandomForestClassifier(n_estimators=num_trees, criterion='gini', min_samples_leaf=2, max_depth=None, verbose=True)
    elif classification == "MLP":
        mlp = MLPClassifier(max_iter=300)

        #Finding the best parameters
        parameter_space = {
            'hidden_layer_sizes': [(100, 100, 100), (256, 256, 256), (100, 164, 256), (256, 100, 50, 50)],
            'activation': ['tanh', 'relu'],
            'solver': ['sgd', 'adam'],
            'alpha': [0.0001, 0.001, 0.01, 0.05, 0.005],
            'learning_rate': ['constant', 'adaptive']
        }

        classifier = GridSearchCV(mlp, parameter_space, n_jobs=-1, cv=3)
    elif classification == "NB":
        classifier = GaussianNB()

    classifier.fit(X_train, y_train_encoded)
    end_time = time.time()

    print(f'It took {(end_time-start_time)/60} minutes to train')

    print("Predicting...")
    start_time = time.time()
    y_pred = classifier.predict(X_test)
    end_time = time.time()

    print(f'It took {(end_time-start_time)/60} minutes to predict')
    
    return y_pred
    
def show_confusion_matrix(y_test, y_pred, class_names, classification):
    confusion_mat = confusion_matrix(y_test, y_pred)

    plt.figure(figsize=(14, 10))
    sns.heatmap(confusion_mat, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.title(f'Malware Confusion Matrix using {classification} classification')
    plt.show()

def main():
    #Load config file
    with open("config.json", "r") as f:
        data = json.load(f)

    df = pd.read_csv(data["mal_path"])

    #Clip the random string of letters and numbers in the label column
    df['Category'] = df['Category'].str.split('-').str.slice(stop=2).str.join('-')

    #Only classify malicious data
    if data["remove_benign"]:
        df = df[df[data["label_column"]] != 'Benign']

    if data["mal_type"]:
        df = df[df[data["label_column"]].str.contains(data["mal_type"])]

    #1. Split the data
    df_train, df_test = train_test_split(df, test_size=0.20, stratify=None)

    X_train = df_train.drop(data["label_column"], axis=1)
    y_train = df_train[data["label_column"]]
    X_test = df_test.drop(data["label_column"], axis=1)
    y_test = df_test[data["label_column"]]

    #Get the encoded labels
    y_train_encoded, y_test_encoded, class_names = encode_labels(y_train, y_test)

    #2. Run the Baseline classifier
    y_pred = multi_class_classification(X_train, y_train_encoded, X_test, data["num_trees"], data["classification"])

    #3. Evaluate the baseline model's performance
    print(classification_report(y_test_encoded, y_pred, target_names=class_names)) 

    class_names = df_train[data["label_column"]].unique()

    if data["gan_model"] == "CTAB":
        synthetic_data = pd.DataFrame()

        for name in class_names:
            print(f'Generating data for {name} class...')
            df_clipped = df_train[df_train[data["label_column"]] == name]
            df_clipped.to_csv("malware_data.csv", index=False)

            ctab = ctabgan.CTABGAN("E:\\ML-Research\\malware_data.csv", test_ratio=0.2, categorical_columns=['Category'], general_columns=['pslist.nproc', 'pslist.nppid', 'pslist.avg_threads','pslist.nprocs64bit', 'pslist.avg_handlers', 'dlllist.ndlls',
                                                        'dlllist.avg_dlls_per_proc','handles.nhandles',	'handles.avg_handles_per_proc',	'handles.nport','handles.nfile',	
                                                        'handles.nevent',	'handles.ndesktop',	'handles.nkey',	'handles.nthread',	'handles.ndirectory',	'handles.nsemaphore',	
                                                        'handles.ntimer',	'handles.nsection',	'handles.nmutant',	'ldrmodules.not_in_load',	'ldrmodules.not_in_init',	
                                                        'ldrmodules.not_in_mem',	'ldrmodules.not_in_load_avg',	'ldrmodules.not_in_init_avg',	'ldrmodules.not_in_mem_avg',	
                                                        'malfind.ninjections',	'malfind.commitCharge',	'malfind.protection',	'malfind.uniqueInjections',	'psxview.not_in_pslist', 
                                                        'psxview.not_in_eprocess_pool',	'psxview.not_in_ethread_pool',	'psxview.not_in_pspcid_list',	'psxview.not_in_csrss_handles', 
                                                        'psxview.not_in_session',	'psxview.not_in_deskthrd',	'psxview.not_in_pslist_false_avg',	'psxview.not_in_eprocess_pool_false_avg', 
                                                        'psxview.not_in_ethread_pool_false_avg', 'psxview.not_in_pspcid_list_false_avg',	'psxview.not_in_csrss_handles_false_avg	psxview.not_in_session_false_avg',	'psxview.not_in_deskthrd_false_avg',	
                                                        'modules.nmodules',	'svcscan.nservices',	'svcscan.kernel_drivers	svcscan.fs_drivers',	'svcscan.process_services',	'svcscan.shared_process_services',	
                                                        'svcscan.interactive_process_services',	'svcscan.nactive',
                                                        'callbacks.ncallbacks',	'callbacks.nanonymous',	'callbacks.ngeneric'], 
                                                        integer_columns=[], problem_type={"Classification": "Category"})


        
            ctab.fit()

            fake_data = ctab.generate_samples(data["num_generated_rows"]) 

            synthetic_data = pd.concat([synthetic_data, fake_data], ignore_index=True)
    
    #4. Use the training data to generate synthetic data
    elif data["gan_model"] == "CT":
        synthetic_data = pd.DataFrame()

        for name in class_names:
            df_clipped = df_train[df_train[data["label_column"]] == name]
            print(f'There are {len(df_clipped)} rows in the {name} class')
            print(f'Generating {data["num_generated_rows"]} samples of synthetic data for {name}...')
            
            #Convert dataframe into metadata
            metadata = SingleTableMetadata()
            metadata.detect_from_dataframe(df_clipped)
            
            synthesizer = CTGANSynthesizer(metadata, verbose=True)
            preprocessed_data = synthesizer.preprocess(df_clipped)
            synthesizer.fit(preprocessed_data)

            fake_data = synthesizer.sample(num_rows=data["num_generated_rows"])

            # Concatenate synthetic_data with the previous data frames
            synthetic_data = pd.concat([synthetic_data, fake_data], ignore_index=True)

        #5. Test how similar the synthetic data is to the real data
        run_diagnostic(
            real_data=df,
            synthetic_data=synthetic_data,
            metadata=metadata,
            verbose=True)
        
        evaluate_quality(
            real_data=df,
            synthetic_data=synthetic_data,
            metadata=metadata,
            verbose=True)
    
        
    #6. Combine the training data and the synthetic data
    X_train_combined = pd.DataFrame()
    y_train_combined = pd.DataFrame()

    df_train_combined = pd.concat([df_train, synthetic_data], ignore_index=True)

    X_train_combined = df_train_combined.drop(data["label_column"], axis=1)
    y_train_combined = df_train_combined[data["label_column"]]

    label_encoder = LabelEncoder()
    y_train_combined_encoded = label_encoder.fit_transform(y_train_combined)

    #7. Train classifier with the combined data
    y_pred_combined = multi_class_classification(X_train_combined, y_train_combined_encoded, X_test, data["num_trees"], data["classification"])

    #8. Evaluate the model's performance with combined data
    print(classification_report(y_test_encoded, y_pred_combined, target_names=class_names))

if __name__ == "__main__":
    main()